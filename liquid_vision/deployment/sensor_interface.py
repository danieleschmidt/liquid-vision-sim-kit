"""
Hardware sensor interface code generation for edge devices.
Provides template code for DVS/DAVIS event camera integration.
"""

from enum import Enum
from typing import Dict, Optional
from pathlib import Path


class SensorType(Enum):
    """Supported event camera sensors."""
    DVS128 = "dvs128"
    DVS240 = "dvs240"
    DVS640 = "dvs640"
    DAVIS346 = "davis346"
    PROPHESEE = "prophesee"
    GENERIC_SPI = "generic_spi"
    GENERIC_I2C = "generic_i2c"


class SensorInterfaceGenerator:
    """Generate sensor interface code for different hardware platforms."""
    
    def __init__(self, sensor_type: SensorType = SensorType.DVS240):
        self.sensor_type = sensor_type
        
    def generate_header(self) -> str:
        """Generate sensor interface header file."""
        return f"""/*
 * Event Camera Sensor Interface
 * Sensor Type: {self.sensor_type.value.upper()}
 * Generated by liquid-vision-sim-kit
 */

#ifndef SENSOR_INTERFACE_H
#define SENSOR_INTERFACE_H

#include <stdint.h>
#include <stdbool.h>

// Sensor configuration
#define SENSOR_TYPE_{self.sensor_type.value.upper()}
{self._get_sensor_defines()}

// Event structure
typedef struct {{
    uint16_t x;
    uint16_t y;
    uint32_t timestamp;
    uint8_t polarity;
}} sensor_event_t;

// Buffer management
typedef struct {{
    sensor_event_t* buffer;
    uint16_t head;
    uint16_t tail;
    uint16_t size;
    bool overflow;
}} event_buffer_t;

// Function declarations
int sensor_init(void);
int sensor_read_events(float* encoded_data, int data_size);
int sensor_read_raw_events(sensor_event_t* events, int max_events);
int sensor_reset(void);
void sensor_cleanup(void);
int sensor_set_bias(uint8_t bias_register, uint16_t value);
bool sensor_data_available(void);

// Buffer management
int event_buffer_init(event_buffer_t* buffer, sensor_event_t* memory, uint16_t size);
int event_buffer_push(event_buffer_t* buffer, sensor_event_t* event);
int event_buffer_pop(event_buffer_t* buffer, sensor_event_t* event);
bool event_buffer_empty(event_buffer_t* buffer);
bool event_buffer_full(event_buffer_t* buffer);
void event_buffer_clear(event_buffer_t* buffer);

// Encoding functions
void encode_events_temporal(sensor_event_t* events, int num_events, float* output);
void encode_events_spatial(sensor_event_t* events, int num_events, float* output);
void encode_events_voxel(sensor_event_t* events, int num_events, float* output);

#endif // SENSOR_INTERFACE_H
"""

    def generate_implementation(self) -> str:
        """Generate sensor interface implementation."""
        return f"""/*
 * Event Camera Sensor Interface Implementation
 * Sensor Type: {self.sensor_type.value.upper()}
 */

#include "sensor_interface.h"
#include "liquid_model.h"
{self._get_platform_includes()}

// Global variables
static event_buffer_t g_event_buffer;
static sensor_event_t g_event_memory[EVENT_BUFFER_SIZE];
static bool g_sensor_initialized = false;
static uint32_t g_last_timestamp = 0;

{self._get_sensor_init_code()}

{self._get_sensor_read_code()}

{self._get_encoding_functions()}

{self._get_buffer_management_code()}

{self._get_cleanup_code()}
"""

    def _get_sensor_defines(self) -> str:
        """Get sensor-specific defines."""
        defines = {
            SensorType.DVS128: """
#define SENSOR_WIDTH 128
#define SENSOR_HEIGHT 128
#define EVENT_BUFFER_SIZE 1024
#define SPI_FREQ_HZ 1000000
""",
            SensorType.DVS240: """
#define SENSOR_WIDTH 240
#define SENSOR_HEIGHT 180
#define EVENT_BUFFER_SIZE 2048
#define SPI_FREQ_HZ 2000000
""",
            SensorType.DVS640: """
#define SENSOR_WIDTH 640
#define SENSOR_HEIGHT 480
#define EVENT_BUFFER_SIZE 4096
#define SPI_FREQ_HZ 4000000
""",
            SensorType.DAVIS346: """
#define SENSOR_WIDTH 346
#define SENSOR_HEIGHT 240
#define EVENT_BUFFER_SIZE 2048
#define HAS_APS_FRAMES 1
#define USB_INTERFACE 1
""",
            SensorType.PROPHESEE: """
#define SENSOR_WIDTH 1280
#define SENSOR_HEIGHT 720
#define EVENT_BUFFER_SIZE 8192
#define USB_INTERFACE 1
#define HIGH_SPEED_MODE 1
""",
            SensorType.GENERIC_SPI: """
#define SENSOR_WIDTH 640
#define SENSOR_HEIGHT 480
#define EVENT_BUFFER_SIZE 2048
#define SPI_FREQ_HZ 2000000
""",
            SensorType.GENERIC_I2C: """
#define SENSOR_WIDTH 240
#define SENSOR_HEIGHT 180
#define EVENT_BUFFER_SIZE 1024
#define I2C_FREQ_HZ 100000
"""
        }
        return defines.get(self.sensor_type, defines[SensorType.DVS240])

    def _get_platform_includes(self) -> str:
        """Get platform-specific includes."""
        return """
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#ifdef ESP_PLATFORM
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/spi_master.h"
#include "driver/gpio.h"
#elif defined(STM32)
#include "stm32f4xx_hal.h"
#else
#include <unistd.h>
#endif
"""

    def _get_sensor_init_code(self) -> str:
        """Get sensor initialization code."""
        return """
int sensor_init(void) {
    if (g_sensor_initialized) {
        return 0; // Already initialized
    }
    
    // Initialize event buffer
    if (event_buffer_init(&g_event_buffer, g_event_memory, EVENT_BUFFER_SIZE) != 0) {
        return -1;
    }
    
#ifdef ESP_PLATFORM
    // ESP32 SPI initialization
    spi_bus_config_t buscfg = {
        .miso_io_num = 19,
        .mosi_io_num = 23,
        .sclk_io_num = 18,
        .quadwp_io_num = -1,
        .quadhd_io_num = -1,
        .max_transfer_sz = 4092
    };
    
    spi_device_interface_config_t devcfg = {
        .clock_speed_hz = SPI_FREQ_HZ,
        .mode = 0,
        .spics_io_num = 5,
        .queue_size = 7
    };
    
    esp_err_t ret = spi_bus_initialize(VSPI_HOST, &buscfg, 1);
    if (ret != ESP_OK) return -2;
    
    ret = spi_bus_add_device(VSPI_HOST, &devcfg, &spi);
    if (ret != ESP_OK) return -3;
    
#elif defined(STM32)
    // STM32 HAL initialization
    hspi1.Instance = SPI1;
    hspi1.Init.Mode = SPI_MODE_MASTER;
    hspi1.Init.Direction = SPI_DIRECTION_2LINES;
    hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
    hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
    hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
    hspi1.Init.NSS = SPI_NSS_SOFT;
    hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;
    hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
    hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
    hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
    
    if (HAL_SPI_Init(&hspi1) != HAL_OK) {
        return -2;
    }
#endif
    
    // Set default bias values
    sensor_set_bias(0x01, 0x55); // Photoreceptor bias
    sensor_set_bias(0x02, 0x33); // Differential bias
    sensor_set_bias(0x03, 0x44); // ON threshold
    sensor_set_bias(0x04, 0x22); // OFF threshold
    
    g_sensor_initialized = true;
    return 0;
}
"""

    def _get_sensor_read_code(self) -> str:
        """Get sensor reading code."""
        return """
int sensor_read_events(float* encoded_data, int data_size) {
    if (!g_sensor_initialized) {
        return -1;
    }
    
    sensor_event_t events[256]; // Temporary buffer
    int num_events = sensor_read_raw_events(events, 256);
    
    if (num_events <= 0) {
        // No events, return zeros
        memset(encoded_data, 0, data_size * sizeof(float));
        return 0;
    }
    
    // Encode events using temporal encoding (default)
    encode_events_temporal(events, num_events, encoded_data);
    return 0;
}

int sensor_read_raw_events(sensor_event_t* events, int max_events) {
    if (!sensor_data_available()) {
        return 0;
    }
    
    int count = 0;
    sensor_event_t event;
    
    // Read events from buffer
    while (count < max_events && !event_buffer_empty(&g_event_buffer)) {
        if (event_buffer_pop(&g_event_buffer, &event) == 0) {
            events[count++] = event;
        }
    }
    
    return count;
}

bool sensor_data_available(void) {
    // Check if data is available from sensor
    // This is platform/sensor specific
    
#ifdef ESP_PLATFORM
    // For ESP32, check GPIO interrupt or poll SPI
    return !event_buffer_empty(&g_event_buffer);
#elif defined(STM32)
    // For STM32, check UART/SPI data ready
    return __HAL_SPI_GET_FLAG(&hspi1, SPI_FLAG_RXNE);
#else
    // For simulation/testing, generate synthetic events
    return true;
#endif
}

int sensor_set_bias(uint8_t bias_register, uint16_t value) {
    uint8_t cmd[3] = {0x80 | bias_register, (value >> 8) & 0xFF, value & 0xFF};
    
#ifdef ESP_PLATFORM
    spi_transaction_t trans = {
        .length = 24,
        .tx_buffer = cmd
    };
    return (spi_device_transmit(spi, &trans) == ESP_OK) ? 0 : -1;
#elif defined(STM32)
    return (HAL_SPI_Transmit(&hspi1, cmd, 3, 100) == HAL_OK) ? 0 : -1;
#else
    printf("Setting bias register 0x%02X to 0x%04X\\n", bias_register, value);
    return 0;
#endif
}
"""

    def _get_encoding_functions(self) -> str:
        """Get event encoding functions."""
        return """
void encode_events_temporal(sensor_event_t* events, int num_events, float* output) {
    // Initialize output
    memset(output, 0, INPUT_DIM * sizeof(float));
    
    // Create temporal surface with exponential decay
    static float temporal_surface[SENSOR_HEIGHT][SENSOR_WIDTH];
    static uint32_t last_update = 0;
    
    // Apply decay if time has passed
    uint32_t current_time = events[num_events-1].timestamp;
    if (current_time > last_update) {
        float decay_factor = expf(-(current_time - last_update) / 20000.0f); // 20ms tau
        for (int y = 0; y < SENSOR_HEIGHT; y++) {
            for (int x = 0; x < SENSOR_WIDTH; x++) {
                temporal_surface[y][x] *= decay_factor;
            }
        }
    }
    
    // Update surface with new events
    for (int i = 0; i < num_events; i++) {
        if (events[i].x < SENSOR_WIDTH && events[i].y < SENSOR_HEIGHT) {
            float value = events[i].polarity ? 1.0f : -1.0f;
            temporal_surface[events[i].y][events[i].x] = value;
        }
    }
    
    // Downsample to output dimensions
    int x_step = SENSOR_WIDTH / (int)sqrtf(INPUT_DIM);
    int y_step = SENSOR_HEIGHT / (int)sqrtf(INPUT_DIM);
    int idx = 0;
    
    for (int y = 0; y < SENSOR_HEIGHT && idx < INPUT_DIM; y += y_step) {
        for (int x = 0; x < SENSOR_WIDTH && idx < INPUT_DIM; x += x_step) {
            output[idx++] = temporal_surface[y][x];
        }
    }
    
    last_update = current_time;
}

void encode_events_spatial(sensor_event_t* events, int num_events, float* output) {
    // Spatial histogram encoding
    memset(output, 0, INPUT_DIM * sizeof(float));
    
    int grid_size = (int)sqrtf(INPUT_DIM / 2); // Divide by 2 for pos/neg channels
    float x_scale = (float)grid_size / SENSOR_WIDTH;
    float y_scale = (float)grid_size / SENSOR_HEIGHT;
    
    for (int i = 0; i < num_events; i++) {
        int x_bin = (int)(events[i].x * x_scale);
        int y_bin = (int)(events[i].y * y_scale);
        
        if (x_bin < grid_size && y_bin < grid_size) {
            int channel = events[i].polarity ? 0 : grid_size * grid_size;
            int idx = channel + y_bin * grid_size + x_bin;
            if (idx < INPUT_DIM) {
                output[idx] += 1.0f;
            }
        }
    }
    
    // Normalize
    float sum = 0.0f;
    for (int i = 0; i < INPUT_DIM; i++) {
        sum += output[i];
    }
    if (sum > 0.0f) {
        for (int i = 0; i < INPUT_DIM; i++) {
            output[i] /= sum;
        }
    }
}

void encode_events_voxel(sensor_event_t* events, int num_events, float* output) {
    // Voxel grid encoding (3D space-time)
    memset(output, 0, INPUT_DIM * sizeof(float));
    
    if (num_events == 0) return;
    
    // Find time range
    uint32_t t_min = events[0].timestamp;
    uint32_t t_max = events[0].timestamp;
    for (int i = 1; i < num_events; i++) {
        if (events[i].timestamp < t_min) t_min = events[i].timestamp;
        if (events[i].timestamp > t_max) t_max = events[i].timestamp;
    }
    
    // Voxel dimensions (assuming cube root division)
    int voxel_dim = (int)cbrtf(INPUT_DIM / 2); // Divide by 2 for polarities
    float x_scale = (float)voxel_dim / SENSOR_WIDTH;
    float y_scale = (float)voxel_dim / SENSOR_HEIGHT;
    float t_scale = (t_max > t_min) ? (float)voxel_dim / (t_max - t_min) : 1.0f;
    
    for (int i = 0; i < num_events; i++) {
        int x_vox = (int)(events[i].x * x_scale);
        int y_vox = (int)(events[i].y * y_scale);
        int t_vox = (int)((events[i].timestamp - t_min) * t_scale);
        
        // Clamp to valid range
        x_vox = (x_vox < 0) ? 0 : (x_vox >= voxel_dim) ? voxel_dim-1 : x_vox;
        y_vox = (y_vox < 0) ? 0 : (y_vox >= voxel_dim) ? voxel_dim-1 : y_vox;
        t_vox = (t_vox < 0) ? 0 : (t_vox >= voxel_dim) ? voxel_dim-1 : t_vox;
        
        // Calculate index
        int channel = events[i].polarity ? 0 : voxel_dim * voxel_dim * voxel_dim;
        int idx = channel + t_vox * voxel_dim * voxel_dim + y_vox * voxel_dim + x_vox;
        
        if (idx < INPUT_DIM) {
            output[idx] += 1.0f;
        }
    }
}
"""

    def _get_buffer_management_code(self) -> str:
        """Get buffer management code."""
        return """
int event_buffer_init(event_buffer_t* buffer, sensor_event_t* memory, uint16_t size) {
    if (!buffer || !memory || size == 0) {
        return -1;
    }
    
    buffer->buffer = memory;
    buffer->size = size;
    buffer->head = 0;
    buffer->tail = 0;
    buffer->overflow = false;
    
    return 0;
}

int event_buffer_push(event_buffer_t* buffer, sensor_event_t* event) {
    if (!buffer || !event) {
        return -1;
    }
    
    uint16_t next_head = (buffer->head + 1) % buffer->size;
    
    if (next_head == buffer->tail) {
        // Buffer full - overwrite oldest
        buffer->overflow = true;
        buffer->tail = (buffer->tail + 1) % buffer->size;
    }
    
    buffer->buffer[buffer->head] = *event;
    buffer->head = next_head;
    
    return 0;
}

int event_buffer_pop(event_buffer_t* buffer, sensor_event_t* event) {
    if (!buffer || !event) {
        return -1;
    }
    
    if (event_buffer_empty(buffer)) {
        return -2; // Buffer empty
    }
    
    *event = buffer->buffer[buffer->tail];
    buffer->tail = (buffer->tail + 1) % buffer->size;
    
    return 0;
}

bool event_buffer_empty(event_buffer_t* buffer) {
    return buffer ? (buffer->head == buffer->tail) : true;
}

bool event_buffer_full(event_buffer_t* buffer) {
    return buffer ? (((buffer->head + 1) % buffer->size) == buffer->tail) : false;
}

void event_buffer_clear(event_buffer_t* buffer) {
    if (buffer) {
        buffer->head = 0;
        buffer->tail = 0;
        buffer->overflow = false;
    }
}
"""

    def _get_cleanup_code(self) -> str:
        """Get cleanup code."""
        return """
int sensor_reset(void) {
    if (!g_sensor_initialized) {
        return -1;
    }
    
    // Clear event buffer
    event_buffer_clear(&g_event_buffer);
    g_last_timestamp = 0;
    
    // Reset sensor hardware
#ifdef ESP_PLATFORM
    // Reset ESP32 SPI
    gpio_set_level(5, 0); // Pull CS low
    vTaskDelay(pdMS_TO_TICKS(10));
    gpio_set_level(5, 1); // Release CS
#elif defined(STM32)
    // Reset STM32 SPI
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_RESET);
    HAL_Delay(10);
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);
#endif
    
    return 0;
}

void sensor_cleanup(void) {
    if (!g_sensor_initialized) {
        return;
    }
    
#ifdef ESP_PLATFORM
    spi_bus_remove_device(spi);
    spi_bus_free(VSPI_HOST);
#elif defined(STM32)
    HAL_SPI_DeInit(&hspi1);
#endif
    
    g_sensor_initialized = false;
}
"""

    def generate_cmake_config(self, project_name: str) -> str:
        """Generate CMakeList.txt for sensor integration."""
        return f"""# CMakeList.txt for {project_name}
cmake_minimum_required(VERSION 3.10)
project({project_name})

# Set C standard
set(CMAKE_C_STANDARD 99)

# Compiler flags
set(CMAKE_C_FLAGS "${{CMAKE_C_FLAGS}} -Wall -Wextra -O2")

# Platform-specific configuration
if(ESP_PLATFORM)
    # ESP-IDF configuration
    idf_component_register(
        SRCS "liquid_model.c" "sensor_interface.c" "main.c"
        INCLUDE_DIRS "."
        REQUIRES freertos driver spi_flash
    )
    
    # ESP32-specific flags
    target_compile_definitions(${{COMPONENT_LIB}} PRIVATE ESP_PLATFORM)
    
elseif(STM32)
    # STM32 HAL configuration
    find_package(PkgConfig REQUIRED)
    
    add_executable({project_name} 
        liquid_model.c 
        sensor_interface.c 
        main.c
    )
    
    target_compile_definitions({project_name} PRIVATE STM32)
    target_link_libraries({project_name} m)
    
else()
    # Generic Linux/desktop build
    add_executable({project_name} 
        liquid_model.c 
        sensor_interface.c 
        main.c
    )
    
    target_link_libraries({project_name} m pthread)
endif()

# Include directories
target_include_directories({project_name} PRIVATE .)

# Optimization for embedded targets
if(CMAKE_BUILD_TYPE STREQUAL "Release")
    target_compile_options({project_name} PRIVATE -Os -ffunction-sections -fdata-sections)
    target_link_options({project_name} PRIVATE -Wl,--gc-sections)
endif()
"""

    def generate_platformio_config(self, project_name: str) -> str:
        """Generate platformio.ini configuration."""
        return f"""; PlatformIO configuration for {project_name}
[env]
framework = espidf
platform = espressif32
board = esp32dev

[env:esp32]
board = esp32dev
monitor_speed = 115200
upload_speed = 921600

build_flags = 
    -DESP_PLATFORM
    -DCONFIG_FREERTOS_HZ=1000
    -O2
    -Wall

lib_deps = 
    
[env:esp32s3]
board = esp32-s3-devkitc-1
monitor_speed = 115200
upload_speed = 921600

build_flags = 
    -DESP_PLATFORM
    -DCONFIG_FREERTOS_HZ=1000
    -O2
    -Wall

[env:stm32]
platform = ststm32
board = nucleo_f401re
framework = stm32cube

build_flags = 
    -DSTM32
    -DSTM32F401xx
    -DUSE_HAL_DRIVER
    -O2
    -Wall

lib_deps = 
    stm32duino/STM32duino FreeRTOS@^10.3.1
"""